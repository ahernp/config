#!/usr/bin/env python3
"""
Updated to remove non-git logic. - Paul Ahern, 23 August 2024

Usage: vcprompt [options]

Version control information in your prompt.

Options:
  -f, --format FORMAT        The format string to use.
  -p, --path PATH            The path to run vcprompt on.
  -s, --systems              Print all known VCSs and exit
  -t, --timeout              The max execution time in milliseconds
  -n, --no-newline           Do not print a trailing newline character
  -v, --version              Show program's version number and exit
  -h, --help                 Show this help message and exit

Formatting options:
  -u, --unknown UNKNOWN      The "unknown" value. Default is "(unknown)"
  -A, --staged UNKNOWN       The "staged" symbol. Default is '*'
  -M, --modified UNKNOWN     The "modified" symbol. Default is '+'
  -U, --untracked UNKNOWN    The "untracked" symbol. Default is '?'

VCS-specific formatting:
  These options can be used for VCS-specific prompt formatting.

  --format-git FORMAT        Git

Format tokens:
  %s, %n                     The VCS "short name" (e.g. git, hg)
  %h                         The hash (or revision number)
  %r                         The revision number (or hash)
  %b                         The currently checked out branch
  %a                         Prints an asterisk if the repo has staged changes
  %m                         Prints plus symbol if the repo is modified
  %u                         Prints question mark if repo has new files
  %P                         The name of the repository root directory
  %p                         The relative path to the repository from cwd
"""

__version__ = "2.0.0"

from subprocess import Popen, PIPE
from xml.dom.minidom import parseString
import errno
import optparse
import os
import re
import shlex
import sys
import threading

try:
    import sqlite3

    has_sqlite3 = True
except ImportError:
    try:
        from pysqlite2 import dbapi2 as sqlite3
    except ImportError:
        has_sqlite3 = False


# user editable options
FORMAT = os.environ.get("VCPROMPT_FORMAT", "%s:%b")
UNKNOWN = os.environ.get("VCPROMPT_UNKNOWN", "(unknown)")
TIMEOUT = os.environ.get("VCPROMPT_TIMEOUT", 0)
SYSTEMS = []

# status indicators
STAGED = os.environ.get("VCPROMPT_STAGED", "*")
MODIFIED = os.environ.get("VCPROMPT_MODIFIED", "+")
UNTRACKED = os.environ.get("VCPROMPT_UNTRACKED", "?")


def popen(command, stdout=PIPE, stderr=PIPE):
    try:
        commands = shlex.split(command)
        process = Popen(commands, stdout=stdout, stderr=stderr)
        output = process.communicate()[0]
        returncode = process.returncode
    except OSError:
        output = ""
        returncode = 1
    return (output, returncode)


# Taken almost wholesale from Python 2.7's posixpath module
def relpath(path, start=os.path.curdir):
    """Return a relative version of a path"""

    if not path:
        raise ValueError("no path specified")

    start_list = [x for x in os.path.abspath(start).split(os.path.sep) if x]
    path_list = [x for x in os.path.abspath(path).split(os.path.sep) if x]

    # Work out how much of the filepath is shared by start and path.
    i = len(os.path.commonprefix([start_list, path_list]))

    rel_list = [os.path.pardir] * (len(start_list) - i) + path_list[i:]
    if not rel_list:
        return os.path.curdir
    return os.path.join(*rel_list)


def helper(*args, **kwargs):
    """
    Prints the help message to stderr.
    """
    sys.stderr.write(__doc__.lstrip())
    sys.exit(0)


def systems(*args, **kwargs):
    """Prints all available systems to stdout."""
    for system in SYSTEMS:
        sys.stdout.write(system.__name__ + "\n")
    sys.exit(0)


def vcs(files):
    """
    Wraps a VCS function, appending it to ``SYSTEMS`` and sets the
    ``file`` attribute.
    """

    def wrapper(function):
        SYSTEMS.append(function)
        function.files = files
        return function

    return wrapper


def version(*args):
    """
    Convenience function for printing a version number.
    """
    sys.stdout.write("vcprompt %s\n" % __version__)
    sys.exit(0)


def vcprompt(options):
    """
    Returns a formatted version control string for use in a shell
    prompt or elsewhere.
    """
    options.path = os.path.abspath(os.path.expanduser(options.path))
    original_path = options.path
    unknown = options.unknown
    prompt = None

    while options.path:
        # bail out on non-existant paths
        if not os.path.exists(options.path):
            break

        # We need to change the current working directory or the '--path'
        # flag might not work correctly with some formatting args.
        # It's easier to do this here, rather than in every VCS function
        if options.path != os.getcwd():
            os.chdir(options.path)

        for vcs in SYSTEMS:
            for vfile in vcs.files:
                if not os.path.exists(vfile):
                    continue

                # set up custom formatting
                vcs_format = getattr(options, "format-" + vcs.__name__, None)
                if vcs_format:
                    options.format = vcs_format

                # the "vcs" file
                options.file = vfile

                conf = vcs(options)
                prompt = options.format

                # Get hash and revision, with fallback to each other
                hash = conf.get("hash", conf.get("revision", unknown))
                revision = conf.get("revision", conf.get("hash", unknown))

                # Substitute stuff
                prompt = prompt.replace("%b", conf.get("branch", unknown))
                prompt = prompt.replace("%r", revision)
                prompt = prompt.replace("%h", hash)
                prompt = prompt.replace("%m", conf.get("modified", ""))
                prompt = prompt.replace("%u", conf.get("untracked", ""))
                prompt = prompt.replace("%a", conf.get("staged", ""))
                prompt = prompt.replace("%s", vcs.__name__)
                prompt = prompt.replace("%n", vcs.__name__)
                prompt = prompt.replace("%P", os.path.basename(options.path))
                prompt = prompt.replace("%p", relpath(original_path, options.path))
                return prompt

        options.path = options.path.rsplit("/", 1)[0]
    return ""


def main():
    parser = optparse.OptionParser()
    parser.remove_option("--help")
    parser.add_option("-h", "--help", action="callback", callback=helper)
    parser.add_option("-f", "--format", dest="format", default=FORMAT)
    parser.add_option("-p", "--path", dest="path", default=".")
    parser.add_option(
        "-n", "--no-newline", action="store_false", dest="newline", default=True
    )
    parser.add_option("-s", "--systems", action="callback", callback=systems)
    parser.add_option("-t", "--timeout", dest="timeout", default=TIMEOUT, type="int")
    parser.add_option("-A", "--staged", dest="staged", default=STAGED)
    parser.add_option("-M", "--modified", dest="modified", default=MODIFIED)
    parser.add_option("-U", "--untracked", dest="untracked", default=UNTRACKED)
    parser.add_option("-u", "--unknown", dest="unknown", default=UNKNOWN)
    parser.add_option("-v", "--version", action="callback", callback=version)

    # vcs-specific formatting
    for system in SYSTEMS:
        default = "VCPROMPT_FORMAT_%s" % system.__name__.upper()
        default = os.environ.get(default, None)
        dest = "format-%s" % system.__name__
        flag = "--%s" % dest
        parser.add_option(flag, dest=dest, default=default)

    options, args = parser.parse_args()

    # set max execution time
    # exit with status errno.ETIME if timeout is reached
    timeout = float(options.timeout) / 1000
    timer = threading.Timer(timeout, lambda: sys.exit(errno.ETIME))
    timer.start()

    output = vcprompt(options)
    if output:
        output = f" {output}"
    if options.newline:
        output += "\n"
    timer.cancel()
    return output


@vcs([".git"])
def git(options):
    """
    Git

    The fast version control system.
    """
    staged = branch = sha = modified = untracked = options.unknown

    if os.path.isfile(options.file):
        fn = open(options.file, "r").read().rstrip("\n").split(" ", 1)[1]
        options.file = fn

    def revstring(ref, chars=7):
        if not os.path.exists(ref):
            # look for packed-refs file in case garbage collection just run
            try:
                pr = os.path.join(options.file, "packed-refs")
                ref = ref.split("/", 1)[1]
                fh = open(pr, "r")
                for line in fh:
                    line = line.strip()
                    if line.endswith(ref):
                        return line.split(" ")[0][0:chars]
                return ""
            except IOError:
                return ""
        try:
            return open(ref, "r").readline()[0:chars]
        except IOError:
            pass
        return ""

    # the current branch is required to get the sha
    if re.search("%(b|r|h)", options.format):
        branch_file = os.path.join(options.file, "HEAD")
        try:
            fh = open(branch_file, "r")
            for line in fh:
                line = line.strip()
                if line.startswith("ref: refs/heads/"):
                    branch = line.split("/", 2)[-1] or options.unknown
                    break
            if branch == options.unknown:
                output, returncode = popen("git describe --always")
                if returncode == 0:
                    branch = "(%s)" % (output.strip())
                else:
                    branch = options.unknown
        except IOError:
            pass

        # sha/revision
        if re.search("%(r|h)", options.format) and branch != options.unknown:
            sha_file = os.path.join(options.file, "refs/heads/%s" % branch)
            sha = revstring(sha_file)

    # modified
    if "%m" in options.format:
        output, returncode = popen("git diff --quiet --exit-code")

        if returncode == 1:
            modified = options.modified
        else:
            modified = ""

    # untracked files
    if "%u" in options.format:
        output, returncode = popen("git ls-files --other --exclude-standard")

        if returncode == 0:
            if output:
                untracked = options.untracked
            else:
                untracked = ""

    # staged files
    if "%a" in options.format:
        output, returncode = popen("git diff --quiet --cached --exit-code")

        if returncode == 1:
            staged = options.staged
        else:
            staged = ""

    # formatting
    return {
        "branch": branch,
        "hash": sha,
        "modified": modified,
        "untracked": untracked,
        "staged": staged,
    }


if __name__ == "__main__":
    prompt = main()
    if prompt:
        sys.stdout.write(prompt)
    else:
        sys.exit(1)
